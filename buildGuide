#============================ Start Up Storm Cluster =============================#
# Start up the cluster
# 1 Start the zookeeper service
zkServer.sh start

# 2 Start nimbus (on numbus host)
storm nimbus

# 3 Start supervisor (on any worker host)
storm supervisor

# 4 Start storm UI
storm ui

#========================== Build Topology ===============================#
# Compile YYY.java and assign corresponding ClassPath (Some jar file and the path which is concatenated by :)
javac -cp xxxx.jar:yyy.jar:. YYY.java

# Make jar file commited to nimbus:
jar cvf test.jar storm-client-2.4.0.jar ExclamationBolt.class WordSpout.class  ExclamationTopology.class

# If there is any external lib => put it in apache-storm-version/extlib (ALL the host must do)
cp kkk.jar ~/apache-storm-2.4.0/extlib/

# Submit the topology to cluster (Under Apache Storm bin directory)
storm jar ZZZ.jar TopologyClass

#============================ System Java version =============================#
#Note: Apache Storm 2.4.0 work fine with openjdk-8-jdk
# 1 Check if openjdk-8-jdk is installed
sudo apt list openjdk-8-jdk

# 2 If not => install it
sudo apt install openjdk-8-jdk

# 3 Check avaliable java version and choose to openjdk-8-jdk
sudo update-alternatives --config java

# 4 Check if the version of java is correct
java -version

# Might get the following environment
openjdk version "1.8.0_352"
OpenJDK Runtime Environment (build 1.8.0_352-8u352-ga-1~22.04-b08)
OpenJDK 64-Bit Server VM (build 25.352-b08, mixed mode)

#============================ Option Setting =============================#
storm.local.dir: "/home/ytc/storm/local"
storm.zookeeper.servers:
  - "localhost"
#     - "server2"
# 
nimbus.seeds: ["192.168.2.132"]
# 
supervisor.slots.ports:
  - 6700
  - 6701
  - 6702
  - 6703
# 
ui.port: 6750

# Set worker heap size
worker.childopts: "-Xmx2g"

#============================ ShellBolt Working directory =================================#
# Note that under Apche Storm ShellBolt, the working directory of python file will be
# the resources directory in the .jar file which you submit
# For example, we can see transfer3to12 service (TfEcgBolt.java)
super("/usr/tf3to12Start.sh", "./tf3to12/tfEcgServerBolt.py");

# It will execute tfEcgServerBolt.py under the path of ./resources/./tf3to12/tfEcgServerBolt.py
# Thus, all your python file might assume that ./resources is your working directory.
# We can see that in resources/tf3to12/tfEcgServerBolt.py 
args_parameter() => ('--modelPath',type=str,default='./tf3to12/step99500.ckpt.meta')

# It loads model from ./tf3to12/XXX.ckpt.meta rather than ./XXX.ckpt.meta even they are in the same directory
# If you load the path ./XXX.ckpt.meta directly, you will get error message telling you that you are not able to find the file

# NOTE: But when you are importing other files in python, you can import directly as they are
# in the same directory (See resources/tf3to12/tfEcgServerBolt.py)
from torch_model import Model3to12
from dbOperation import MongoDB 
# That is weird, but just follow it

#============================ ShellBolt python version (Pyenv)=============================#
# Note that in ShellBolt, this might execute /usr/bin/python (Guess)
# So it won't be affected by pyenv to switch versions between python
super("python", "myExector.py")  

# Experiment: 
#  1. Try to switch python version to 3.9.16 with no any python librarys installed,
#     but all process works well (No module name doesn't happen)

# Thus modify the super to the command below
# and now we can use pyenv global {version}
# and will actually make the system's python version changed
# (Now No module name occurs)
super("/home/ytc/.pyenv/shims/python", "myExecutor.py")

# Notice that all the command below can't be used
super("$HOME/.pyenv/shims/python", "myExecutor.py")
super("~/.pyenv/shims/python", "myExecutor.py")

# So, we write a shell script which will execute ~/.pyenv/shims/python 
# then, we can execute different python by modifing the content of this shell script
# The content in the file is now
~/.pyenv/shims/python $1 

# Finally, put it at /usr/pystart.sh (Remember to chmod +x this file)
# Now in ShellBolt, the actually command is
super("/usr/pystart.sh", "myExector.py")  

#============================ ShellBolt python version (Miniconda)=============================#
# We also need a shellscript to help us execute python under a certain user 
# because executing $HOME/... or ~/... is invalid
super("/usr/hfonlyStart.sh", "hfInfServerBolt.py");

# The content in such file is like this. And we can know that if we execute python under miniconda3/envs/MYENV/bin/python
# we can use the package and dependencies under this environment
~/miniconda3/envs/hfonly/bin/python $1

